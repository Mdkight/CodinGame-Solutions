import java.util.*;
import java.io.*;
import java.lang.Math;

/**
 * My chosen approach for Code Vs Zombies was to choose a human as a target based on the most thretened
 * human that I could reach in time to save while also checking what would give me the best score
 * then move towards that target. I would also constantly revaluate to find a human that was saveable and would give a better score
 * it worked, passing every test case, but it didn't get the total score I wanted. 
 * so I attempted a genetic algoroithm (found in CVZGeneticAlgo.java)
 * 
 * comments in this code were generated by ChatGPT based on my existing code
 **/

class Player {

    public static double distance(int x1, int y1, int x2, int y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Variables to lock onto a target
        int lockedTargetX = -1;
        int lockedTargetY = -1;
        boolean hasLockedTarget = false;

        // Main game loop
        while (true) {
            // Reading Ash's position
            int ashX = scanner.nextInt();
            int ashY = scanner.nextInt();

            // Reading Humans' data
            int humanCount = scanner.nextInt();
            List<int[]> humans = new ArrayList<>();
            for (int i = 0; i < humanCount; i++) {
                int humanId = scanner.nextInt();
                int humanX = scanner.nextInt();
                int humanY = scanner.nextInt();
                humans.add(new int[]{humanId, humanX, humanY});
            }

            // Reading Zombies' data
            int zombieCount = scanner.nextInt();
            List<int[]> zombies = new ArrayList<>();
            for (int i = 0; i < zombieCount; i++) {
                int zombieId = scanner.nextInt();
                int zombieX = scanner.nextInt();
                int zombieY = scanner.nextInt();
                int zombieNextX = scanner.nextInt();
                int zombieNextY = scanner.nextInt();
                zombies.add(new int[]{zombieId, zombieX, zombieY, zombieNextX, zombieNextY});
            }

            // Choosing the target - optimize for maximizing score
            int targetX = 0, targetY = 0;
            double maxScore = Double.NEGATIVE_INFINITY;

            // Evaluate each potential move
            for (int[] human : humans) {
                int humanX = human[1];
                int humanY = human[2];
                
                // Calculate how critical it is to save this human
                double totalThreatLevel = 0;
                for (int[] zombie : zombies) {
                    int zombieX = zombie[1];
                    int zombieY = zombie[2];
                    double zombieDistanceToHuman = distance(humanX, humanY, zombieX, zombieY);
                    totalThreatLevel += 1.0 / (zombieDistanceToHuman + 1); // Higher threat for closer zombies
                }

                // Calculate Ash's potential score if moving towards this human
                double potentialScore = 0;
                for (int[] zombie : zombies) {
                    int zombieX = zombie[1];
                    int zombieY = zombie[2];
                    double distanceToAsh = distance(ashX, ashY, zombieX, zombieY);

                    // Check if Ash can reach and shoot the zombie
                    if (distanceToAsh <= 2000) {
                        // Calculate score based on number of humans alive
                        potentialScore += Math.pow(humanCount, 2) * 10;

                        // Apply Fibonacci multiplier for killing multiple zombies in the same turn
                        int zombiesKilled = 0;
                        for (int[] otherZombie : zombies) {
                            double distToOtherZombie = distance(ashX, ashY, otherZombie[1], otherZombie[2]);
                            if (distToOtherZombie <= 2000) {
                                zombiesKilled++;
                            }
                        }
                        if (zombiesKilled > 1) {
                            potentialScore *= fibonacci(zombiesKilled + 2);
                        }
                    }
                }

                // Combine score with the need to protect humans
                double humanSurvivalScore = (1 / distance(ashX, ashY, humanX, humanY)) - totalThreatLevel;
                double finalScore = potentialScore + humanSurvivalScore;

                if (finalScore > maxScore) {
                    maxScore = finalScore;
                    targetX = humanX;
                    targetY = humanY;
                }
            }

            // Lock onto the target if not already locked or if a significantly better target is found
            if (!hasLockedTarget || maxScore > 1.5 * distance(ashX, ashY, lockedTargetX, lockedTargetY)) {
                lockedTargetX = targetX;
                lockedTargetY = targetY;
                hasLockedTarget = true;
            }

            // Output target coordinates
            System.out.println(lockedTargetX + " " + lockedTargetY + " Heading to maximize score");
        }
    }

    // Function to calculate the nth Fibonacci number (assuming n >= 1)
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        int a = 1, b = 1;
        for (int i = 3; i <= n; i++) {
            int c = a + b;
            a = b;
            b = c;
        }
        return b;
    }
}
